# day 6

Visit elements starting from the end of array

```scala
for(I <- ( 0 until a.length.reverse)
	println(it ": " + arr1(i))
```
If you don't need the array index in the loop body, visit the array elements directly.

```scala
for (elem <- a) println(elem)
```

The variable elem is set to a(0), then a(1) and so on.

Transforming arrays: such transformtion don't mofity the original array, but they yield a new one.
a1: Array[Int]
```scala
val a1 = Array(2,3,5,7,11)
```

use a for comprehasion
result: Array[Int] double each elements
```scala
val result1 = for(elem <- a1) yield z*elem
```

for(...) yield loop creates a new collection of the same type as the original collection. if you start with  an array, you get another array.
The result data structure(collection) contains the expressions after the yield, one for each iteration of the loop.
double every even element, dropping the odds ones

```scala
val result2 = for(elem <-a if elem%2 == 0) yield 2*elem
```
no mutation in the for loop
